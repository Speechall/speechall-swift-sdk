// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Upload an audio file directly and receive a transcription.
    ///
    /// This endpoint allows you to send raw audio data in the request body for transcription.
    /// You can specify the desired model, language, output format, and various provider-specific features using query parameters.
    /// Suitable for transcribing local audio files.
    ///
    ///
    /// - Remark: HTTP `POST /transcribe`.
    /// - Remark: Generated from `#/paths//transcribe/post(transcribe)`.
    func transcribe(_ input: Operations.transcribe.Input) async throws -> Operations.transcribe.Output
    /// Transcribe an audio file located at a remote URL.
    ///
    /// This endpoint allows you to transcribe an audio file hosted at a publicly accessible URL.
    /// Provide the URL and transcription options within the JSON request body.
    /// Useful for transcribing files already stored online.
    ///
    ///
    /// - Remark: HTTP `POST /transcribe-remote`.
    /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)`.
    func transcribeRemote(_ input: Operations.transcribeRemote.Input) async throws -> Operations.transcribeRemote.Output
    /// Transcribes audio into the input language, using OpenAI-compatible request format.
    ///
    /// Mimics the OpenAI `/audio/transcriptions` endpoint. Accepts audio file uploads via `multipart/form-data`.
    /// Allows specifying model, language, prompt, response format, temperature, and timestamp granularity similar to OpenAI.
    /// Note: The `model` parameter should use Speechall's `provider.model` format.
    ///
    ///
    /// - Remark: HTTP `POST /openai-compatible/audio/transcriptions`.
    /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)`.
    func openaiCompatibleCreateTranscription(_ input: Operations.openaiCompatibleCreateTranscription.Input) async throws -> Operations.openaiCompatibleCreateTranscription.Output
    /// Translates audio into English, using OpenAI-compatible request format.
    ///
    /// Mimics the OpenAI `/audio/translations` endpoint. Accepts audio file uploads via `multipart/form-data` and translates the speech into English text.
    /// Allows specifying model, prompt, response format, and temperature similar to OpenAI.
    /// Note: The `model` parameter should use Speechall's `provider.model` format (ensure the selected model supports translation).
    ///
    ///
    /// - Remark: HTTP `POST /openai-compatible/audio/translations`.
    /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)`.
    func openaiCompatibleCreateTranslation(_ input: Operations.openaiCompatibleCreateTranslation.Input) async throws -> Operations.openaiCompatibleCreateTranslation.Output
    /// Create a reusable set of text replacement rules.
    ///
    /// Defines a named set of replacement rules (exact match, regex) that can be applied during transcription requests using its `ruleset_id`.
    /// Rules within a set are applied sequentially to the transcription text.
    ///
    ///
    /// - Remark: HTTP `POST /replacement-rulesets`.
    /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)`.
    func createReplacementRuleset(_ input: Operations.createReplacementRuleset.Input) async throws -> Operations.createReplacementRuleset.Output
    /// Retrieve a list of all available speech-to-text models.
    ///
    /// Returns a detailed list of all STT models accessible through the Speechall API.
    /// Each model entry includes its identifier (`provider.model`), display name, description,
    /// supported features (languages, formats, punctuation, diarization), and performance characteristics.
    /// Use this endpoint to discover available models and their capabilities before making transcription requests.
    ///
    ///
    /// - Remark: HTTP `GET /speech-to-text-models`.
    /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)`.
    func listSpeechToTextModels(_ input: Operations.listSpeechToTextModels.Input) async throws -> Operations.listSpeechToTextModels.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Upload an audio file directly and receive a transcription.
    ///
    /// This endpoint allows you to send raw audio data in the request body for transcription.
    /// You can specify the desired model, language, output format, and various provider-specific features using query parameters.
    /// Suitable for transcribing local audio files.
    ///
    ///
    /// - Remark: HTTP `POST /transcribe`.
    /// - Remark: Generated from `#/paths//transcribe/post(transcribe)`.
    public func transcribe(
        query: Operations.transcribe.Input.Query,
        headers: Operations.transcribe.Input.Headers = .init(),
        body: Operations.transcribe.Input.Body
    ) async throws -> Operations.transcribe.Output {
        try await transcribe(Operations.transcribe.Input(
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Transcribe an audio file located at a remote URL.
    ///
    /// This endpoint allows you to transcribe an audio file hosted at a publicly accessible URL.
    /// Provide the URL and transcription options within the JSON request body.
    /// Useful for transcribing files already stored online.
    ///
    ///
    /// - Remark: HTTP `POST /transcribe-remote`.
    /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)`.
    public func transcribeRemote(
        headers: Operations.transcribeRemote.Input.Headers = .init(),
        body: Operations.transcribeRemote.Input.Body
    ) async throws -> Operations.transcribeRemote.Output {
        try await transcribeRemote(Operations.transcribeRemote.Input(
            headers: headers,
            body: body
        ))
    }
    /// Transcribes audio into the input language, using OpenAI-compatible request format.
    ///
    /// Mimics the OpenAI `/audio/transcriptions` endpoint. Accepts audio file uploads via `multipart/form-data`.
    /// Allows specifying model, language, prompt, response format, temperature, and timestamp granularity similar to OpenAI.
    /// Note: The `model` parameter should use Speechall's `provider.model` format.
    ///
    ///
    /// - Remark: HTTP `POST /openai-compatible/audio/transcriptions`.
    /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)`.
    public func openaiCompatibleCreateTranscription(
        headers: Operations.openaiCompatibleCreateTranscription.Input.Headers = .init(),
        body: Operations.openaiCompatibleCreateTranscription.Input.Body
    ) async throws -> Operations.openaiCompatibleCreateTranscription.Output {
        try await openaiCompatibleCreateTranscription(Operations.openaiCompatibleCreateTranscription.Input(
            headers: headers,
            body: body
        ))
    }
    /// Translates audio into English, using OpenAI-compatible request format.
    ///
    /// Mimics the OpenAI `/audio/translations` endpoint. Accepts audio file uploads via `multipart/form-data` and translates the speech into English text.
    /// Allows specifying model, prompt, response format, and temperature similar to OpenAI.
    /// Note: The `model` parameter should use Speechall's `provider.model` format (ensure the selected model supports translation).
    ///
    ///
    /// - Remark: HTTP `POST /openai-compatible/audio/translations`.
    /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)`.
    public func openaiCompatibleCreateTranslation(
        headers: Operations.openaiCompatibleCreateTranslation.Input.Headers = .init(),
        body: Operations.openaiCompatibleCreateTranslation.Input.Body
    ) async throws -> Operations.openaiCompatibleCreateTranslation.Output {
        try await openaiCompatibleCreateTranslation(Operations.openaiCompatibleCreateTranslation.Input(
            headers: headers,
            body: body
        ))
    }
    /// Create a reusable set of text replacement rules.
    ///
    /// Defines a named set of replacement rules (exact match, regex) that can be applied during transcription requests using its `ruleset_id`.
    /// Rules within a set are applied sequentially to the transcription text.
    ///
    ///
    /// - Remark: HTTP `POST /replacement-rulesets`.
    /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)`.
    public func createReplacementRuleset(
        headers: Operations.createReplacementRuleset.Input.Headers = .init(),
        body: Operations.createReplacementRuleset.Input.Body
    ) async throws -> Operations.createReplacementRuleset.Output {
        try await createReplacementRuleset(Operations.createReplacementRuleset.Input(
            headers: headers,
            body: body
        ))
    }
    /// Retrieve a list of all available speech-to-text models.
    ///
    /// Returns a detailed list of all STT models accessible through the Speechall API.
    /// Each model entry includes its identifier (`provider.model`), display name, description,
    /// supported features (languages, formats, punctuation, diarization), and performance characteristics.
    /// Use this endpoint to discover available models and their capabilities before making transcription requests.
    ///
    ///
    /// - Remark: HTTP `GET /speech-to-text-models`.
    /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)`.
    public func listSpeechToTextModels(headers: Operations.listSpeechToTextModels.Input.Headers = .init()) async throws -> Operations.listSpeechToTextModels.Output {
        try await listSpeechToTextModels(Operations.listSpeechToTextModels.Input(headers: headers))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    /// The version 1 endpoint of the Speechall API.
    public enum Server1 {
        /// The version 1 endpoint of the Speechall API.
        public static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "https://api.speechall.com/v1",
                variables: []
            )
        }
    }
    /// The version 1 endpoint of the Speechall API.
    @available(*, deprecated, renamed: "Servers.Server1.url")
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "https://api.speechall.com/v1",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// The identifier for the underlying Speech-to-Text service provider (e.g., 'openai', 'deepgram').
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptionProvider`.
        @frozen public enum TranscriptionProvider: String, Codable, Hashable, Sendable, CaseIterable {
            case amazon = "amazon"
            case assemblyai = "assemblyai"
            case azure = "azure"
            case cloudflare = "cloudflare"
            case deepgram = "deepgram"
            case elevenlabs = "elevenlabs"
            case falai = "falai"
            case fireworksai = "fireworksai"
            case gemini = "gemini"
            case gladia = "gladia"
            case google = "google"
            case groq = "groq"
            case ibm = "ibm"
            case mistral = "mistral"
            case openai = "openai"
            case revai = "revai"
            case speechmatics = "speechmatics"
        }
        /// Unique identifier for a specific Speech-to-Text model, composed as `provider.model_name`. Used to select the engine for transcription.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptionModelIdentifier`.
        @frozen public enum TranscriptionModelIdentifier: String, Codable, Hashable, Sendable, CaseIterable {
            case amazon_period_transcribe = "amazon.transcribe"
            case assemblyai_period_best = "assemblyai.best"
            case assemblyai_period_nano = "assemblyai.nano"
            case assemblyai_period_slam_hyphen_1 = "assemblyai.slam-1"
            case assemblyai_period_universal = "assemblyai.universal"
            case azure_period_standard = "azure.standard"
            case cloudflare_period_whisper = "cloudflare.whisper"
            case cloudflare_period_whisper_hyphen_large_hyphen_v3_hyphen_turbo = "cloudflare.whisper-large-v3-turbo"
            case cloudflare_period_whisper_hyphen_tiny_hyphen_en = "cloudflare.whisper-tiny-en"
            case deepgram_period_base = "deepgram.base"
            case deepgram_period_base_hyphen_conversationalai = "deepgram.base-conversationalai"
            case deepgram_period_base_hyphen_finance = "deepgram.base-finance"
            case deepgram_period_base_hyphen_general = "deepgram.base-general"
            case deepgram_period_base_hyphen_meeting = "deepgram.base-meeting"
            case deepgram_period_base_hyphen_phonecall = "deepgram.base-phonecall"
            case deepgram_period_base_hyphen_video = "deepgram.base-video"
            case deepgram_period_base_hyphen_voicemail = "deepgram.base-voicemail"
            case deepgram_period_enhanced = "deepgram.enhanced"
            case deepgram_period_enhanced_hyphen_finance = "deepgram.enhanced-finance"
            case deepgram_period_enhanced_hyphen_general = "deepgram.enhanced-general"
            case deepgram_period_enhanced_hyphen_meeting = "deepgram.enhanced-meeting"
            case deepgram_period_enhanced_hyphen_phonecall = "deepgram.enhanced-phonecall"
            case deepgram_period_nova = "deepgram.nova"
            case deepgram_period_nova_hyphen_general = "deepgram.nova-general"
            case deepgram_period_nova_hyphen_phonecall = "deepgram.nova-phonecall"
            case deepgram_period_nova_hyphen_2 = "deepgram.nova-2"
            case deepgram_period_nova_hyphen_2_hyphen_atc = "deepgram.nova-2-atc"
            case deepgram_period_nova_hyphen_2_hyphen_automotive = "deepgram.nova-2-automotive"
            case deepgram_period_nova_hyphen_2_hyphen_conversationalai = "deepgram.nova-2-conversationalai"
            case deepgram_period_nova_hyphen_2_hyphen_drivethru = "deepgram.nova-2-drivethru"
            case deepgram_period_nova_hyphen_2_hyphen_finance = "deepgram.nova-2-finance"
            case deepgram_period_nova_hyphen_2_hyphen_general = "deepgram.nova-2-general"
            case deepgram_period_nova_hyphen_2_hyphen_medical = "deepgram.nova-2-medical"
            case deepgram_period_nova_hyphen_2_hyphen_meeting = "deepgram.nova-2-meeting"
            case deepgram_period_nova_hyphen_2_hyphen_phonecall = "deepgram.nova-2-phonecall"
            case deepgram_period_nova_hyphen_2_hyphen_video = "deepgram.nova-2-video"
            case deepgram_period_nova_hyphen_2_hyphen_voicemail = "deepgram.nova-2-voicemail"
            case deepgram_period_nova_hyphen_3 = "deepgram.nova-3"
            case deepgram_period_nova_hyphen_3_hyphen_general = "deepgram.nova-3-general"
            case deepgram_period_nova_hyphen_3_hyphen_medical = "deepgram.nova-3-medical"
            case deepgram_period_whisper = "deepgram.whisper"
            case deepgram_period_whisper_hyphen_base = "deepgram.whisper-base"
            case deepgram_period_whisper_hyphen_large = "deepgram.whisper-large"
            case deepgram_period_whisper_hyphen_medium = "deepgram.whisper-medium"
            case deepgram_period_whisper_hyphen_small = "deepgram.whisper-small"
            case deepgram_period_whisper_hyphen_tiny = "deepgram.whisper-tiny"
            case elevenlabs_period_scribe_hyphen_v1 = "elevenlabs.scribe-v1"
            case falai_period_elevenlabs_hyphen_speech_hyphen_to_hyphen_text = "falai.elevenlabs-speech-to-text"
            case falai_period_speech_hyphen_to_hyphen_text = "falai.speech-to-text"
            case falai_period_whisper = "falai.whisper"
            case falai_period_wizper = "falai.wizper"
            case fireworksai_period_whisper_hyphen_v3 = "fireworksai.whisper-v3"
            case fireworksai_period_whisper_hyphen_v3_hyphen_turbo = "fireworksai.whisper-v3-turbo"
            case gladia_period_standard = "gladia.standard"
            case google_period_enhanced = "google.enhanced"
            case google_period_standard = "google.standard"
            case gemini_period_gemini_hyphen_2_period_5_hyphen_pro = "gemini.gemini-2.5-pro"
            case gemini_period_gemini_hyphen_2_period_5_hyphen_flash = "gemini.gemini-2.5-flash"
            case gemini_period_gemini_hyphen_2_period_5_hyphen_flash_hyphen_lite = "gemini.gemini-2.5-flash-lite"
            case gemini_period_gemini_hyphen_2_period_0_hyphen_flash = "gemini.gemini-2.0-flash"
            case gemini_period_gemini_hyphen_2_period_0_hyphen_flash_hyphen_lite = "gemini.gemini-2.0-flash-lite"
            case groq_period_whisper_hyphen_large_hyphen_v3 = "groq.whisper-large-v3"
            case groq_period_whisper_hyphen_large_hyphen_v3_hyphen_turbo = "groq.whisper-large-v3-turbo"
            case ibm_period_standard = "ibm.standard"
            case mistral_period_voxtral_hyphen_mini = "mistral.voxtral-mini"
            case openai_period_whisper_hyphen_1 = "openai.whisper-1"
            case openai_period_gpt_hyphen_4o_hyphen_transcribe = "openai.gpt-4o-transcribe"
            case openai_period_gpt_hyphen_4o_hyphen_mini_hyphen_transcribe = "openai.gpt-4o-mini-transcribe"
            case openai_period_gpt_hyphen_4o_hyphen_transcribe_hyphen_diarize = "openai.gpt-4o-transcribe-diarize"
            case revai_period_machine = "revai.machine"
            case revai_period_fusion = "revai.fusion"
            case speechmatics_period_enhanced = "speechmatics.enhanced"
            case speechmatics_period_standard = "speechmatics.standard"
        }
        /// Common configuration options for transcription, applicable to both direct uploads and remote URLs.
        ///
        /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration`.
        public struct BaseTranscriptionConfiguration: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/model`.
            public var model: Components.Schemas.TranscriptionModelIdentifier
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/language`.
            public var language: Components.Schemas.TranscriptLanguageCode?
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/output_format`.
            public var output_format: Components.Schemas.TranscriptOutputFormat?
            /// The unique identifier (UUID) of a pre-defined replacement ruleset to apply to the final transcription text.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/ruleset_id`.
            public var ruleset_id: Swift.String?
            /// Whether to add punctuation. Support varies by model (e.g., Deepgram, AssemblyAI). Defaults to `true`.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/punctuation`.
            public var punctuation: Swift.Bool?
            /// Enable speaker diarization. Defaults to `false`.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/diarization`.
            public var diarization: Swift.Bool?
            /// Optional text prompt to guide the transcription model. Support varies (e.g., OpenAI).
            ///
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/initial_prompt`.
            public var initial_prompt: Swift.String?
            /// Controls output randomness for supported models (e.g., OpenAI). Value between 0 and 1.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/temperature`.
            public var temperature: Swift.Double?
            /// Hint for the number of expected speakers for diarization (e.g., RevAI, Deepgram).
            ///
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/speakers_expected`.
            public var speakers_expected: Swift.Int?
            /// List of custom words/phrases to improve recognition (e.g., Deepgram, AssemblyAI).
            ///
            /// - Remark: Generated from `#/components/schemas/BaseTranscriptionConfiguration/custom_vocabulary`.
            public var custom_vocabulary: [Swift.String]?
            /// Creates a new `BaseTranscriptionConfiguration`.
            ///
            /// - Parameters:
            ///   - model:
            ///   - language:
            ///   - output_format:
            ///   - ruleset_id: The unique identifier (UUID) of a pre-defined replacement ruleset to apply to the final transcription text.
            ///   - punctuation: Whether to add punctuation. Support varies by model (e.g., Deepgram, AssemblyAI). Defaults to `true`.
            ///   - diarization: Enable speaker diarization. Defaults to `false`.
            ///   - initial_prompt: Optional text prompt to guide the transcription model. Support varies (e.g., OpenAI).
            ///   - temperature: Controls output randomness for supported models (e.g., OpenAI). Value between 0 and 1.
            ///   - speakers_expected: Hint for the number of expected speakers for diarization (e.g., RevAI, Deepgram).
            ///   - custom_vocabulary: List of custom words/phrases to improve recognition (e.g., Deepgram, AssemblyAI).
            public init(
                model: Components.Schemas.TranscriptionModelIdentifier,
                language: Components.Schemas.TranscriptLanguageCode? = nil,
                output_format: Components.Schemas.TranscriptOutputFormat? = nil,
                ruleset_id: Swift.String? = nil,
                punctuation: Swift.Bool? = nil,
                diarization: Swift.Bool? = nil,
                initial_prompt: Swift.String? = nil,
                temperature: Swift.Double? = nil,
                speakers_expected: Swift.Int? = nil,
                custom_vocabulary: [Swift.String]? = nil
            ) {
                self.model = model
                self.language = language
                self.output_format = output_format
                self.ruleset_id = ruleset_id
                self.punctuation = punctuation
                self.diarization = diarization
                self.initial_prompt = initial_prompt
                self.temperature = temperature
                self.speakers_expected = speakers_expected
                self.custom_vocabulary = custom_vocabulary
            }
            public enum CodingKeys: String, CodingKey {
                case model
                case language
                case output_format
                case ruleset_id
                case punctuation
                case diarization
                case initial_prompt
                case temperature
                case speakers_expected
                case custom_vocabulary
            }
        }
        /// Configuration options for transcribing audio specified by a remote URL via the `/transcribe-remote` endpoint.
        ///
        /// - Remark: Generated from `#/components/schemas/RemoteTranscriptionConfiguration`.
        public struct RemoteTranscriptionConfiguration: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/RemoteTranscriptionConfiguration/value1`.
            public var value1: Components.Schemas.BaseTranscriptionConfiguration
            /// - Remark: Generated from `#/components/schemas/RemoteTranscriptionConfiguration/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// The publicly accessible URL of the audio file to transcribe. The API server must be able to fetch the audio from this URL.
                ///
                /// - Remark: Generated from `#/components/schemas/RemoteTranscriptionConfiguration/value2/file_url`.
                public var file_url: Swift.String
                /// An array of replacement rules to be applied directly to this transcription request, in order. This allows defining rules inline instead of (or in addition to) using a pre-saved `ruleset_id`.
                ///
                /// - Remark: Generated from `#/components/schemas/RemoteTranscriptionConfiguration/value2/replacement_ruleset`.
                public var replacement_ruleset: [Components.Schemas.ReplacementRule]?
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - file_url: The publicly accessible URL of the audio file to transcribe. The API server must be able to fetch the audio from this URL.
                ///   - replacement_ruleset: An array of replacement rules to be applied directly to this transcription request, in order. This allows defining rules inline instead of (or in addition to) using a pre-saved `ruleset_id`.
                public init(
                    file_url: Swift.String,
                    replacement_ruleset: [Components.Schemas.ReplacementRule]? = nil
                ) {
                    self.file_url = file_url
                    self.replacement_ruleset = replacement_ruleset
                }
                public enum CodingKeys: String, CodingKey {
                    case file_url
                    case replacement_ruleset
                }
            }
            /// - Remark: Generated from `#/components/schemas/RemoteTranscriptionConfiguration/value2`.
            public var value2: Components.Schemas.RemoteTranscriptionConfiguration.Value2Payload
            /// Creates a new `RemoteTranscriptionConfiguration`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.BaseTranscriptionConfiguration,
                value2: Components.Schemas.RemoteTranscriptionConfiguration.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
                self.value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
                try self.value2.encode(to: encoder)
            }
        }
        /// The language code of the audio file, typically in ISO 639-1 format.
        /// Specifying the correct language improves transcription accuracy and speed.
        /// The special value `auto` can be used to request automatic language detection, if supported by the selected model.
        /// If omitted, the default language is English (`en`).
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptLanguageCode`.
        @frozen public enum TranscriptLanguageCode: String, Codable, Hashable, Sendable, CaseIterable {
            case auto = "auto"
            case en = "en"
            case en_au = "en_au"
            case en_uk = "en_uk"
            case en_us = "en_us"
            case af = "af"
            case am = "am"
            case ar = "ar"
            case _as = "as"
            case az = "az"
            case ba = "ba"
            case be = "be"
            case bg = "bg"
            case bn = "bn"
            case bo = "bo"
            case br = "br"
            case bs = "bs"
            case ca = "ca"
            case cs = "cs"
            case cy = "cy"
            case da = "da"
            case de = "de"
            case el = "el"
            case es = "es"
            case et = "et"
            case eu = "eu"
            case fa = "fa"
            case fi = "fi"
            case fo = "fo"
            case fr = "fr"
            case gl = "gl"
            case gu = "gu"
            case ha = "ha"
            case haw = "haw"
            case he = "he"
            case hi = "hi"
            case hr = "hr"
            case ht = "ht"
            case hu = "hu"
            case hy = "hy"
            case id = "id"
            case _is = "is"
            case it = "it"
            case ja = "ja"
            case jw = "jw"
            case ka = "ka"
            case kk = "kk"
            case km = "km"
            case kn = "kn"
            case ko = "ko"
            case la = "la"
            case lb = "lb"
            case ln = "ln"
            case lo = "lo"
            case lt = "lt"
            case lv = "lv"
            case mg = "mg"
            case mi = "mi"
            case mk = "mk"
            case ml = "ml"
            case mn = "mn"
            case mr = "mr"
            case ms = "ms"
            case mt = "mt"
            case my = "my"
            case ne = "ne"
            case nl = "nl"
            case nn = "nn"
            case _false = "false"
            case oc = "oc"
            case pa = "pa"
            case pl = "pl"
            case ps = "ps"
            case pt = "pt"
            case ro = "ro"
            case ru = "ru"
            case sa = "sa"
            case sd = "sd"
            case si = "si"
            case sk = "sk"
            case sl = "sl"
            case sn = "sn"
            case so = "so"
            case sq = "sq"
            case sr = "sr"
            case su = "su"
            case sv = "sv"
            case sw = "sw"
            case ta = "ta"
            case te = "te"
            case tg = "tg"
            case th = "th"
            case tk = "tk"
            case tl = "tl"
            case tr = "tr"
            case tt = "tt"
            case uk = "uk"
            case ur = "ur"
            case uz = "uz"
            case vi = "vi"
            case yi = "yi"
            case yo = "yo"
            case zh = "zh"
        }
        /// Specifies the desired format of the transcription output.
        /// - `text`: Plain text containing the full transcription.
        /// - `json_text`: A simple JSON object containing the transcription ID and the full text (`TranscriptionOnlyText` schema).
        /// - `json`: A detailed JSON object including segments, timestamps (based on `timestamp_granularity`), language, and potentially speaker labels and provider metadata (`TranscriptionDetailed` schema).
        /// - `srt`: SubRip subtitle format (returned as plain text).
        /// - `vtt`: WebVTT subtitle format (returned as plain text).
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptOutputFormat`.
        @frozen public enum TranscriptOutputFormat: String, Codable, Hashable, Sendable, CaseIterable {
            case text = "text"
            case json_text = "json_text"
            case json = "json"
            case srt = "srt"
            case vtt = "vtt"
        }
        /// A simplified JSON response format containing only the transcription ID and the full transcribed text. Returned when `output_format` is `json_text`.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptionOnlyText`.
        public struct TranscriptionOnlyText: Codable, Hashable, Sendable {
            /// A unique identifier for the transcription job/request.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionOnlyText/id`.
            public var id: Swift.String
            /// The full transcribed text as a single string.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionOnlyText/text`.
            public var text: Swift.String
            /// Creates a new `TranscriptionOnlyText`.
            ///
            /// - Parameters:
            ///   - id: A unique identifier for the transcription job/request.
            ///   - text: The full transcribed text as a single string.
            public init(
                id: Swift.String,
                text: Swift.String
            ) {
                self.id = id
                self.text = text
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case text
            }
        }
        /// A detailed JSON response format containing the full text, detected language, duration, individual timed segments, and potentially speaker labels and provider-specific metadata. Returned when `output_format` is `json`.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptionDetailed`.
        public struct TranscriptionDetailed: Codable, Hashable, Sendable {
            /// A unique identifier for the transcription job/request.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionDetailed/id`.
            public var id: Swift.String
            /// The full transcribed text as a single string.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionDetailed/text`.
            public var text: Swift.String
            /// The detected or specified language of the audio (ISO 639-1 code).
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionDetailed/language`.
            public var language: Swift.String?
            /// An array of transcribed segments, providing time-coded chunks of the transcription. May include speaker labels if diarization was enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionDetailed/segments`.
            public var segments: [Components.Schemas.TranscriptionSegment]?
            /// An array of transcribed words, providing time-coded chunks of the transcription. May include speaker labels if diarization was enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionDetailed/words`.
            public var words: [Components.Schemas.TranscriptionWord]?
            /// Creates a new `TranscriptionDetailed`.
            ///
            /// - Parameters:
            ///   - id: A unique identifier for the transcription job/request.
            ///   - text: The full transcribed text as a single string.
            ///   - language: The detected or specified language of the audio (ISO 639-1 code).
            ///   - segments: An array of transcribed segments, providing time-coded chunks of the transcription. May include speaker labels if diarization was enabled.
            ///   - words: An array of transcribed words, providing time-coded chunks of the transcription. May include speaker labels if diarization was enabled.
            public init(
                id: Swift.String,
                text: Swift.String,
                language: Swift.String? = nil,
                segments: [Components.Schemas.TranscriptionSegment]? = nil,
                words: [Components.Schemas.TranscriptionWord]? = nil
            ) {
                self.id = id
                self.text = text
                self.language = language
                self.segments = segments
                self.words = words
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case text
                case language
                case segments
                case words
            }
        }
        /// Represents the JSON structure returned when a JSON-based `output_format` (`json` or `json_text`) is requested. It can be either a detailed structure or a simple text-only structure.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptionResponse`.
        @frozen public enum TranscriptionResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TranscriptionResponse/case1`.
            case TranscriptionDetailed(Components.Schemas.TranscriptionDetailed)
            /// - Remark: Generated from `#/components/schemas/TranscriptionResponse/case2`.
            case TranscriptionOnlyText(Components.Schemas.TranscriptionOnlyText)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .TranscriptionDetailed(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .TranscriptionOnlyText(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .TranscriptionDetailed(value):
                    try value.encode(to: encoder)
                case let .TranscriptionOnlyText(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// Represents a time-coded segment of the transcription, typically corresponding to a phrase, sentence, or speaker turn.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptionSegment`.
        public struct TranscriptionSegment: Codable, Hashable, Sendable {
            /// The start time of the segment in seconds from the beginning of the audio.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/start`.
            public var start: Swift.Double?
            /// The end time of the segment in seconds from the beginning of the audio.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/end`.
            public var end: Swift.Double?
            /// The transcribed text content of this segment.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/text`.
            public var text: Swift.String?
            /// An identifier for the speaker of this segment, present if diarization was enabled and successful.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/speaker`.
            public var speaker: Swift.String?
            /// The model's confidence score for the transcription of this segment, typically between 0 and 1 (if provided by the model).
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionSegment/confidence`.
            public var confidence: Swift.Double?
            /// Creates a new `TranscriptionSegment`.
            ///
            /// - Parameters:
            ///   - start: The start time of the segment in seconds from the beginning of the audio.
            ///   - end: The end time of the segment in seconds from the beginning of the audio.
            ///   - text: The transcribed text content of this segment.
            ///   - speaker: An identifier for the speaker of this segment, present if diarization was enabled and successful.
            ///   - confidence: The model's confidence score for the transcription of this segment, typically between 0 and 1 (if provided by the model).
            public init(
                start: Swift.Double? = nil,
                end: Swift.Double? = nil,
                text: Swift.String? = nil,
                speaker: Swift.String? = nil,
                confidence: Swift.Double? = nil
            ) {
                self.start = start
                self.end = end
                self.text = text
                self.speaker = speaker
                self.confidence = confidence
            }
            public enum CodingKeys: String, CodingKey {
                case start
                case end
                case text
                case speaker
                case confidence
            }
        }
        /// Represents a word in the transcription, providing time-coded chunks of the transcription.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscriptionWord`.
        public struct TranscriptionWord: Codable, Hashable, Sendable {
            /// The start time of the word in seconds from the beginning of the audio.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionWord/start`.
            public var start: Swift.Double
            /// The end time of the word in seconds from the beginning of the audio.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionWord/end`.
            public var end: Swift.Double
            /// The transcribed word.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionWord/word`.
            public var word: Swift.String
            /// An identifier for the speaker of this word, present if diarization was enabled and successful.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionWord/speaker`.
            public var speaker: Swift.String?
            /// The model's confidence score for the transcription of this word, typically between 0 and 1 (if provided by the model).
            ///
            /// - Remark: Generated from `#/components/schemas/TranscriptionWord/confidence`.
            public var confidence: Swift.Double?
            /// Creates a new `TranscriptionWord`.
            ///
            /// - Parameters:
            ///   - start: The start time of the word in seconds from the beginning of the audio.
            ///   - end: The end time of the word in seconds from the beginning of the audio.
            ///   - word: The transcribed word.
            ///   - speaker: An identifier for the speaker of this word, present if diarization was enabled and successful.
            ///   - confidence: The model's confidence score for the transcription of this word, typically between 0 and 1 (if provided by the model).
            public init(
                start: Swift.Double,
                end: Swift.Double,
                word: Swift.String,
                speaker: Swift.String? = nil,
                confidence: Swift.Double? = nil
            ) {
                self.start = start
                self.end = end
                self.word = word
                self.speaker = speaker
                self.confidence = confidence
            }
            public enum CodingKeys: String, CodingKey {
                case start
                case end
                case word
                case speaker
                case confidence
            }
        }
        /// Describes an available speech-to-text model, its provider, capabilities, and characteristics.
        ///
        /// - Remark: Generated from `#/components/schemas/SpeechToTextModel`.
        public struct SpeechToTextModel: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/id`.
            public var id: Components.Schemas.TranscriptionModelIdentifier
            /// A user-friendly name for the model.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/display_name`.
            public var display_name: Swift.String
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/provider`.
            public var provider: Components.Schemas.TranscriptionProvider
            /// A brief description of the model, its intended use case, or version notes.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/description`.
            public var description: Swift.String?
            /// The cost per second of audio processed in USD.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/cost_per_second_usd`.
            public var cost_per_second_usd: Swift.Double?
            /// Indicates whether the model is currently available for use.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/is_available`.
            public var is_available: Swift.Bool
            /// A list of language codes (preferably BCP 47, e.g., "en-US", "en-GB", "es-ES") supported by this model. May include `auto` if automatic language detection is supported across multiple languages within a single audio file.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/supported_languages`.
            public var supported_languages: [Swift.String]?
            /// Indicates whether the model generally supports automatic punctuation insertion.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/punctuation`.
            public var punctuation: Swift.Bool?
            /// Indicates whether the model generally supports speaker diarization (identifying different speakers).
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/diarization`.
            public var diarization: Swift.Bool?
            /// Indicates whether the model can be used for real-time streaming transcription via a WebSocket connection (if offered by Speechall).
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/streamable`.
            public var streamable: Swift.Bool?
            /// An approximate measure of processing speed for batch processing. Defined as (audio duration) / (processing time). A higher value means faster processing (e.g., RTF=2 means it processes 1 second of audio in 0.5 seconds). May not be available for all models or streaming scenarios.
            ///
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/real_time_factor`.
            public var real_time_factor: Swift.Double?
            /// The maximum duration of a single audio file (in seconds) that the model can reliably process in one request. May vary by provider or plan.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/max_duration_seconds`.
            public var max_duration_seconds: Swift.Double?
            /// The maximum size of a single audio file (in bytes) that can be uploaded for processing by this model. May vary by provider or plan.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/max_file_size_bytes`.
            public var max_file_size_bytes: Swift.Int64?
            /// The specific version identifier for the model.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/version`.
            public var version: Swift.String?
            /// The date when this specific version of the model was released or last updated.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/release_date`.
            public var release_date: Swift.String?
            /// The primary type or training domain of the model. Helps identify suitability for different audio types.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/model_type`.
            @frozen public enum model_typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case general = "general"
                case phone_call = "phone_call"
                case video = "video"
                case command_and_search = "command_and_search"
                case medical = "medical"
                case legal = "legal"
                case voicemail = "voicemail"
                case meeting = "meeting"
            }
            /// The primary type or training domain of the model. Helps identify suitability for different audio types.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/model_type`.
            public var model_type: Components.Schemas.SpeechToTextModel.model_typePayload?
            /// A general indication of the model's expected accuracy level relative to other models. Not a guaranteed metric.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/accuracy_tier`.
            @frozen public enum accuracy_tierPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case basic = "basic"
                case standard = "standard"
                case enhanced = "enhanced"
                case premium = "premium"
            }
            /// A general indication of the model's expected accuracy level relative to other models. Not a guaranteed metric.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/accuracy_tier`.
            public var accuracy_tier: Components.Schemas.SpeechToTextModel.accuracy_tierPayload?
            /// A list of audio encodings that this model supports or is optimized for (e.g., LINEAR16, FLAC, MP3, Opus).
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/supported_audio_encodings`.
            public var supported_audio_encodings: [Swift.String]?
            /// A list of audio sample rates (in Hz) that this model supports or is optimized for.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/supported_sample_rates`.
            public var supported_sample_rates: [Swift.Int]?
            /// Indicates whether the model can provide speaker labels for the transcription.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/speaker_labels`.
            public var speaker_labels: Swift.Bool?
            /// Indicates whether the model can provide timestamps for individual words.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/word_timestamps`.
            public var word_timestamps: Swift.Bool?
            /// Indicates whether the model provides confidence scores for the transcription or individual words.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/confidence_scores`.
            public var confidence_scores: Swift.Bool?
            /// Indicates whether the model supports automatic language detection for input audio.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/language_detection`.
            public var language_detection: Swift.Bool?
            /// Indicates if the model can leverage a custom vocabulary or language model adaptation.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/custom_vocabulary_support`.
            public var custom_vocabulary_support: Swift.Bool?
            /// Indicates if the model supports filtering or masking of profanity.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/profanity_filtering`.
            public var profanity_filtering: Swift.Bool?
            /// Indicates if the model supports noise reduction.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/noise_reduction`.
            public var noise_reduction: Swift.Bool?
            /// Indicates whether the model supports SRT subtitle format output.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/supports_srt`.
            public var supports_srt: Swift.Bool
            /// Indicates whether the model supports VTT subtitle format output.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/supports_vtt`.
            public var supports_vtt: Swift.Bool
            /// Indicates whether the model supports voice activity detection (VAD) to identify speech segments.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextModel/voice_activity_detection`.
            public var voice_activity_detection: Swift.Bool?
            /// Creates a new `SpeechToTextModel`.
            ///
            /// - Parameters:
            ///   - id:
            ///   - display_name: A user-friendly name for the model.
            ///   - provider:
            ///   - description: A brief description of the model, its intended use case, or version notes.
            ///   - cost_per_second_usd: The cost per second of audio processed in USD.
            ///   - is_available: Indicates whether the model is currently available for use.
            ///   - supported_languages: A list of language codes (preferably BCP 47, e.g., "en-US", "en-GB", "es-ES") supported by this model. May include `auto` if automatic language detection is supported across multiple languages within a single audio file.
            ///   - punctuation: Indicates whether the model generally supports automatic punctuation insertion.
            ///   - diarization: Indicates whether the model generally supports speaker diarization (identifying different speakers).
            ///   - streamable: Indicates whether the model can be used for real-time streaming transcription via a WebSocket connection (if offered by Speechall).
            ///   - real_time_factor: An approximate measure of processing speed for batch processing. Defined as (audio duration) / (processing time). A higher value means faster processing (e.g., RTF=2 means it processes 1 second of audio in 0.5 seconds). May not be available for all models or streaming scenarios.
            ///   - max_duration_seconds: The maximum duration of a single audio file (in seconds) that the model can reliably process in one request. May vary by provider or plan.
            ///   - max_file_size_bytes: The maximum size of a single audio file (in bytes) that can be uploaded for processing by this model. May vary by provider or plan.
            ///   - version: The specific version identifier for the model.
            ///   - release_date: The date when this specific version of the model was released or last updated.
            ///   - model_type: The primary type or training domain of the model. Helps identify suitability for different audio types.
            ///   - accuracy_tier: A general indication of the model's expected accuracy level relative to other models. Not a guaranteed metric.
            ///   - supported_audio_encodings: A list of audio encodings that this model supports or is optimized for (e.g., LINEAR16, FLAC, MP3, Opus).
            ///   - supported_sample_rates: A list of audio sample rates (in Hz) that this model supports or is optimized for.
            ///   - speaker_labels: Indicates whether the model can provide speaker labels for the transcription.
            ///   - word_timestamps: Indicates whether the model can provide timestamps for individual words.
            ///   - confidence_scores: Indicates whether the model provides confidence scores for the transcription or individual words.
            ///   - language_detection: Indicates whether the model supports automatic language detection for input audio.
            ///   - custom_vocabulary_support: Indicates if the model can leverage a custom vocabulary or language model adaptation.
            ///   - profanity_filtering: Indicates if the model supports filtering or masking of profanity.
            ///   - noise_reduction: Indicates if the model supports noise reduction.
            ///   - supports_srt: Indicates whether the model supports SRT subtitle format output.
            ///   - supports_vtt: Indicates whether the model supports VTT subtitle format output.
            ///   - voice_activity_detection: Indicates whether the model supports voice activity detection (VAD) to identify speech segments.
            public init(
                id: Components.Schemas.TranscriptionModelIdentifier,
                display_name: Swift.String,
                provider: Components.Schemas.TranscriptionProvider,
                description: Swift.String? = nil,
                cost_per_second_usd: Swift.Double? = nil,
                is_available: Swift.Bool,
                supported_languages: [Swift.String]? = nil,
                punctuation: Swift.Bool? = nil,
                diarization: Swift.Bool? = nil,
                streamable: Swift.Bool? = nil,
                real_time_factor: Swift.Double? = nil,
                max_duration_seconds: Swift.Double? = nil,
                max_file_size_bytes: Swift.Int64? = nil,
                version: Swift.String? = nil,
                release_date: Swift.String? = nil,
                model_type: Components.Schemas.SpeechToTextModel.model_typePayload? = nil,
                accuracy_tier: Components.Schemas.SpeechToTextModel.accuracy_tierPayload? = nil,
                supported_audio_encodings: [Swift.String]? = nil,
                supported_sample_rates: [Swift.Int]? = nil,
                speaker_labels: Swift.Bool? = nil,
                word_timestamps: Swift.Bool? = nil,
                confidence_scores: Swift.Bool? = nil,
                language_detection: Swift.Bool? = nil,
                custom_vocabulary_support: Swift.Bool? = nil,
                profanity_filtering: Swift.Bool? = nil,
                noise_reduction: Swift.Bool? = nil,
                supports_srt: Swift.Bool,
                supports_vtt: Swift.Bool,
                voice_activity_detection: Swift.Bool? = nil
            ) {
                self.id = id
                self.display_name = display_name
                self.provider = provider
                self.description = description
                self.cost_per_second_usd = cost_per_second_usd
                self.is_available = is_available
                self.supported_languages = supported_languages
                self.punctuation = punctuation
                self.diarization = diarization
                self.streamable = streamable
                self.real_time_factor = real_time_factor
                self.max_duration_seconds = max_duration_seconds
                self.max_file_size_bytes = max_file_size_bytes
                self.version = version
                self.release_date = release_date
                self.model_type = model_type
                self.accuracy_tier = accuracy_tier
                self.supported_audio_encodings = supported_audio_encodings
                self.supported_sample_rates = supported_sample_rates
                self.speaker_labels = speaker_labels
                self.word_timestamps = word_timestamps
                self.confidence_scores = confidence_scores
                self.language_detection = language_detection
                self.custom_vocabulary_support = custom_vocabulary_support
                self.profanity_filtering = profanity_filtering
                self.noise_reduction = noise_reduction
                self.supports_srt = supports_srt
                self.supports_vtt = supports_vtt
                self.voice_activity_detection = voice_activity_detection
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case display_name
                case provider
                case description
                case cost_per_second_usd
                case is_available
                case supported_languages
                case punctuation
                case diarization
                case streamable
                case real_time_factor
                case max_duration_seconds
                case max_file_size_bytes
                case version
                case release_date
                case model_type
                case accuracy_tier
                case supported_audio_encodings
                case supported_sample_rates
                case speaker_labels
                case word_timestamps
                case confidence_scores
                case language_detection
                case custom_vocabulary_support
                case profanity_filtering
                case noise_reduction
                case supports_srt
                case supports_vtt
                case voice_activity_detection
            }
        }
        /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionRequest`.
        @frozen public enum OpenAI_CreateTranscriptionRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionRequest/file`.
            public struct filePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `filePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case file(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranscriptionRequest.filePayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionRequest/model`.
            public struct modelPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `modelPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case model(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranscriptionRequest.modelPayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionRequest/language`.
            public struct languagePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `languagePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case language(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranscriptionRequest.languagePayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionRequest/prompt`.
            public struct promptPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `promptPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case prompt(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranscriptionRequest.promptPayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionRequest/response_format`.
            public struct response_formatPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `response_formatPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case response_format(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranscriptionRequest.response_formatPayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionRequest/temperature`.
            public struct temperaturePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `temperaturePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case temperature(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranscriptionRequest.temperaturePayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionRequest/timestamp_granularities[]`.
            public struct timestamp_granularities_lbrack__rbrack_Payload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `timestamp_granularities_lbrack__rbrack_Payload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case timestamp_granularities_lbrack__rbrack_(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranscriptionRequest.timestamp_granularities_lbrack__rbrack_Payload>)
        }
        /// Represents a transcription response returned by model, based on the provided input.
        ///
        /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionResponseJson`.
        public struct OpenAI_CreateTranscriptionResponseJson: Codable, Hashable, Sendable {
            /// The transcribed text.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionResponseJson/text`.
            public var text: Swift.String
            /// Creates a new `OpenAI_CreateTranscriptionResponseJson`.
            ///
            /// - Parameters:
            ///   - text: The transcribed text.
            public init(text: Swift.String) {
                self.text = text
            }
            public enum CodingKeys: String, CodingKey {
                case text
            }
        }
        /// Represents a verbose json transcription response returned by model, based on the provided input.
        ///
        /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionResponseVerboseJson`.
        public struct OpenAI_CreateTranscriptionResponseVerboseJson: Codable, Hashable, Sendable {
            /// The language of the input audio.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionResponseVerboseJson/language`.
            public var language: Swift.String
            /// The duration of the input audio.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionResponseVerboseJson/duration`.
            public var duration: Swift.Double
            /// The transcribed text.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionResponseVerboseJson/text`.
            public var text: Swift.String
            /// Extracted words and their corresponding timestamps.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionResponseVerboseJson/words`.
            public var words: [Components.Schemas.OpenAI_TranscriptionWord]?
            /// Segments of the transcribed text and their corresponding details.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranscriptionResponseVerboseJson/segments`.
            public var segments: [Components.Schemas.OpenAI_TranscriptionSegment]?
            /// Creates a new `OpenAI_CreateTranscriptionResponseVerboseJson`.
            ///
            /// - Parameters:
            ///   - language: The language of the input audio.
            ///   - duration: The duration of the input audio.
            ///   - text: The transcribed text.
            ///   - words: Extracted words and their corresponding timestamps.
            ///   - segments: Segments of the transcribed text and their corresponding details.
            public init(
                language: Swift.String,
                duration: Swift.Double,
                text: Swift.String,
                words: [Components.Schemas.OpenAI_TranscriptionWord]? = nil,
                segments: [Components.Schemas.OpenAI_TranscriptionSegment]? = nil
            ) {
                self.language = language
                self.duration = duration
                self.text = text
                self.words = words
                self.segments = segments
            }
            public enum CodingKeys: String, CodingKey {
                case language
                case duration
                case text
                case words
                case segments
            }
        }
        /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationRequest`.
        @frozen public enum OpenAI_CreateTranslationRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationRequest/file`.
            public struct filePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `filePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case file(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranslationRequest.filePayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationRequest/model`.
            public struct modelPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `modelPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case model(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranslationRequest.modelPayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationRequest/prompt`.
            public struct promptPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `promptPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case prompt(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranslationRequest.promptPayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationRequest/response_format`.
            public struct response_formatPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `response_formatPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case response_format(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranslationRequest.response_formatPayload>)
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationRequest/temperature`.
            public struct temperaturePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `temperaturePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case temperature(OpenAPIRuntime.MultipartPart<Components.Schemas.OpenAI_CreateTranslationRequest.temperaturePayload>)
        }
        /// Standard JSON response for OpenAI-compatible translation requests when `response_format` is `json`. Contains the translated English text.
        ///
        /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationResponseJson`.
        public struct OpenAI_CreateTranslationResponseJson: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationResponseJson/text`.
            public var text: Swift.String
            /// Creates a new `OpenAI_CreateTranslationResponseJson`.
            ///
            /// - Parameters:
            ///   - text:
            public init(text: Swift.String) {
                self.text = text
            }
            public enum CodingKeys: String, CodingKey {
                case text
            }
        }
        /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationResponseVerboseJson`.
        public struct OpenAI_CreateTranslationResponseVerboseJson: Codable, Hashable, Sendable {
            /// The language of the output translation (always `english`).
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationResponseVerboseJson/language`.
            public var language: Swift.String
            /// The duration of the input audio.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationResponseVerboseJson/duration`.
            public var duration: Swift.String
            /// The translated text.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationResponseVerboseJson/text`.
            public var text: Swift.String
            /// Segments of the translated text and their corresponding details.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_CreateTranslationResponseVerboseJson/segments`.
            public var segments: [Components.Schemas.OpenAI_TranscriptionSegment]?
            /// Creates a new `OpenAI_CreateTranslationResponseVerboseJson`.
            ///
            /// - Parameters:
            ///   - language: The language of the output translation (always `english`).
            ///   - duration: The duration of the input audio.
            ///   - text: The translated text.
            ///   - segments: Segments of the translated text and their corresponding details.
            public init(
                language: Swift.String,
                duration: Swift.String,
                text: Swift.String,
                segments: [Components.Schemas.OpenAI_TranscriptionSegment]? = nil
            ) {
                self.language = language
                self.duration = duration
                self.text = text
                self.segments = segments
            }
            public enum CodingKeys: String, CodingKey {
                case language
                case duration
                case text
                case segments
            }
        }
        /// The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.
        ///
        ///
        /// - Remark: Generated from `#/components/schemas/OpenAI_AudioResponseFormat`.
        @frozen public enum OpenAI_AudioResponseFormat: String, Codable, Hashable, Sendable, CaseIterable {
            case json = "json"
            case text = "text"
            case srt = "srt"
            case verbose_json = "verbose_json"
            case vtt = "vtt"
        }
        /// Represents a segment of transcribed or translated text, based on OpenAI's verbose JSON structure.
        ///
        /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment`.
        public struct OpenAI_TranscriptionSegment: Codable, Hashable, Sendable {
            /// Unique identifier of the segment.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/id`.
            public var id: Swift.Int
            /// Seek offset of the segment.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/seek`.
            public var seek: Swift.Int
            /// Start time of the segment in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/start`.
            public var start: Swift.Float
            /// End time of the segment in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/end`.
            public var end: Swift.Float
            /// Text content of the segment.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/text`.
            public var text: Swift.String
            /// Array of token IDs for the text content.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/tokens`.
            public var tokens: [Swift.Int]
            /// Temperature parameter used for generating the segment.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/temperature`.
            public var temperature: Swift.Float
            /// Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/avg_logprob`.
            public var avg_logprob: Swift.Float
            /// Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/compression_ratio`.
            public var compression_ratio: Swift.Float
            /// Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionSegment/no_speech_prob`.
            public var no_speech_prob: Swift.Float
            /// Creates a new `OpenAI_TranscriptionSegment`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the segment.
            ///   - seek: Seek offset of the segment.
            ///   - start: Start time of the segment in seconds.
            ///   - end: End time of the segment in seconds.
            ///   - text: Text content of the segment.
            ///   - tokens: Array of token IDs for the text content.
            ///   - temperature: Temperature parameter used for generating the segment.
            ///   - avg_logprob: Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
            ///   - compression_ratio: Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
            ///   - no_speech_prob: Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
            public init(
                id: Swift.Int,
                seek: Swift.Int,
                start: Swift.Float,
                end: Swift.Float,
                text: Swift.String,
                tokens: [Swift.Int],
                temperature: Swift.Float,
                avg_logprob: Swift.Float,
                compression_ratio: Swift.Float,
                no_speech_prob: Swift.Float
            ) {
                self.id = id
                self.seek = seek
                self.start = start
                self.end = end
                self.text = text
                self.tokens = tokens
                self.temperature = temperature
                self.avg_logprob = avg_logprob
                self.compression_ratio = compression_ratio
                self.no_speech_prob = no_speech_prob
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case seek
                case start
                case end
                case text
                case tokens
                case temperature
                case avg_logprob
                case compression_ratio
                case no_speech_prob
            }
        }
        /// Represents a single word identified during transcription, including its start and end times. Included in `verbose_json` response when `word` granularity is requested.
        ///
        /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionWord`.
        public struct OpenAI_TranscriptionWord: Codable, Hashable, Sendable {
            /// The text content of the word.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionWord/word`.
            public var word: Swift.String
            /// Start time of the word in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionWord/start`.
            public var start: Swift.Float
            /// End time of the word in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/OpenAI_TranscriptionWord/end`.
            public var end: Swift.Float
            /// Creates a new `OpenAI_TranscriptionWord`.
            ///
            /// - Parameters:
            ///   - word: The text content of the word.
            ///   - start: Start time of the word in seconds.
            ///   - end: End time of the word in seconds.
            public init(
                word: Swift.String,
                start: Swift.Float,
                end: Swift.Float
            ) {
                self.word = word
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case word
                case start
                case end
            }
        }
        /// Standard structure for error responses. May include additional properties depending on the error type.
        ///
        /// - Remark: Generated from `#/components/schemas/ErrorResponse`.
        public struct ErrorResponse: Codable, Hashable, Sendable {
            /// A human-readable message describing the error.
            ///
            /// - Remark: Generated from `#/components/schemas/ErrorResponse/message`.
            public var message: Swift.String
            /// A container of undocumented properties.
            public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
            /// Creates a new `ErrorResponse`.
            ///
            /// - Parameters:
            ///   - message: A human-readable message describing the error.
            ///   - additionalProperties: A container of undocumented properties.
            public init(
                message: Swift.String,
                additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()
            ) {
                self.message = message
                self.additionalProperties = additionalProperties
            }
            public enum CodingKeys: String, CodingKey {
                case message
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.message = try container.decode(
                    Swift.String.self,
                    forKey: .message
                )
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [
                    "message"
                ])
            }
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(
                    self.message,
                    forKey: .message
                )
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
        /// Defines a replacement rule based on finding an exact string match.
        ///
        /// - Remark: Generated from `#/components/schemas/ExactRule`.
        public struct ExactRule: Codable, Hashable, Sendable {
            /// Discriminator field identifying the rule type as 'exact'.
            ///
            /// - Remark: Generated from `#/components/schemas/ExactRule/kind`.
            @frozen public enum kindPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case exact = "exact"
            }
            /// Discriminator field identifying the rule type as 'exact'.
            ///
            /// - Remark: Generated from `#/components/schemas/ExactRule/kind`.
            public var kind: Components.Schemas.ExactRule.kindPayload
            /// The exact text string to search for within the transcription.
            ///
            /// - Remark: Generated from `#/components/schemas/ExactRule/search`.
            public var search: Swift.String
            /// The text string to replace the found 'search' text with.
            ///
            /// - Remark: Generated from `#/components/schemas/ExactRule/replacement`.
            public var replacement: Swift.String
            /// If true, the search will match only if the case is identical. If false (default), the search ignores case.
            ///
            /// - Remark: Generated from `#/components/schemas/ExactRule/caseSensitive`.
            public var caseSensitive: Swift.Bool?
            /// Creates a new `ExactRule`.
            ///
            /// - Parameters:
            ///   - kind: Discriminator field identifying the rule type as 'exact'.
            ///   - search: The exact text string to search for within the transcription.
            ///   - replacement: The text string to replace the found 'search' text with.
            ///   - caseSensitive: If true, the search will match only if the case is identical. If false (default), the search ignores case.
            public init(
                kind: Components.Schemas.ExactRule.kindPayload,
                search: Swift.String,
                replacement: Swift.String,
                caseSensitive: Swift.Bool? = nil
            ) {
                self.kind = kind
                self.search = search
                self.replacement = replacement
                self.caseSensitive = caseSensitive
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case search
                case replacement
                case caseSensitive
            }
        }
        /// Defines a replacement rule based on matching a regular expression pattern.
        ///
        /// - Remark: Generated from `#/components/schemas/RegexRule`.
        public struct RegexRule: Codable, Hashable, Sendable {
            /// Discriminator field identifying the rule type as 'regex'.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexRule/kind`.
            @frozen public enum kindPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case regex = "regex"
            }
            /// Discriminator field identifying the rule type as 'regex'.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexRule/kind`.
            public var kind: Components.Schemas.RegexRule.kindPayload
            /// The regular expression pattern to search for. Uses standard regex syntax (implementation specific, often PCRE-like). Remember to escape special characters if needed (e.g., `\\.` for a literal dot).
            ///
            /// - Remark: Generated from `#/components/schemas/RegexRule/pattern`.
            public var pattern: Swift.String
            /// The replacement text. Can include backreferences to capture groups from the pattern, like `$1`, `$2`, etc. A literal `$` should be escaped (e.g., `$$`).
            ///
            /// - Remark: Generated from `#/components/schemas/RegexRule/replacement`.
            public var replacement: Swift.String
            /// - Remark: Generated from `#/components/schemas/RegexRule/flagsPayload`.
            @frozen public enum flagsPayloadPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case i = "i"
                case m = "m"
                case s = "s"
                case x = "x"
                case u = "u"
            }
            /// An array of flags to modify the regex behavior (e.g., 'i' for case-insensitivity).
            ///
            /// - Remark: Generated from `#/components/schemas/RegexRule/flags`.
            public typealias flagsPayload = [Components.Schemas.RegexRule.flagsPayloadPayload]
            /// An array of flags to modify the regex behavior (e.g., 'i' for case-insensitivity).
            ///
            /// - Remark: Generated from `#/components/schemas/RegexRule/flags`.
            public var flags: Components.Schemas.RegexRule.flagsPayload?
            /// Creates a new `RegexRule`.
            ///
            /// - Parameters:
            ///   - kind: Discriminator field identifying the rule type as 'regex'.
            ///   - pattern: The regular expression pattern to search for. Uses standard regex syntax (implementation specific, often PCRE-like). Remember to escape special characters if needed (e.g., `\\.` for a literal dot).
            ///   - replacement: The replacement text. Can include backreferences to capture groups from the pattern, like `$1`, `$2`, etc. A literal `$` should be escaped (e.g., `$$`).
            ///   - flags: An array of flags to modify the regex behavior (e.g., 'i' for case-insensitivity).
            public init(
                kind: Components.Schemas.RegexRule.kindPayload,
                pattern: Swift.String,
                replacement: Swift.String,
                flags: Components.Schemas.RegexRule.flagsPayload? = nil
            ) {
                self.kind = kind
                self.pattern = pattern
                self.replacement = replacement
                self.flags = flags
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case pattern
                case replacement
                case flags
            }
        }
        /// Defines a replacement rule that uses regex capture groups to apply different replacements to different parts of the matched text.
        ///
        /// - Remark: Generated from `#/components/schemas/RegexGroupRule`.
        public struct RegexGroupRule: Codable, Hashable, Sendable {
            /// Discriminator field identifying the rule type as 'regex_group'.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexGroupRule/kind`.
            @frozen public enum kindPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case regex_group = "regex_group"
            }
            /// Discriminator field identifying the rule type as 'regex_group'.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexGroupRule/kind`.
            public var kind: Components.Schemas.RegexGroupRule.kindPayload
            /// The regular expression pattern containing capture groups `(...)`. The entire pattern must match for replacements to occur.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexGroupRule/pattern`.
            public var pattern: Swift.String
            /// An object where keys are capture group numbers (as strings, e.g., "1", "2") and values are the respective replacement strings for those groups. Groups not listed are kept as matched. The entire match is reconstructed using these replacements.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexGroupRule/groupReplacements`.
            public struct groupReplacementsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `groupReplacementsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// An object where keys are capture group numbers (as strings, e.g., "1", "2") and values are the respective replacement strings for those groups. Groups not listed are kept as matched. The entire match is reconstructed using these replacements.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexGroupRule/groupReplacements`.
            public var groupReplacements: Components.Schemas.RegexGroupRule.groupReplacementsPayload
            /// - Remark: Generated from `#/components/schemas/RegexGroupRule/flagsPayload`.
            @frozen public enum flagsPayloadPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case i = "i"
                case m = "m"
                case s = "s"
                case x = "x"
                case u = "u"
            }
            /// An array of flags to modify the regex behavior.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexGroupRule/flags`.
            public typealias flagsPayload = [Components.Schemas.RegexGroupRule.flagsPayloadPayload]
            /// An array of flags to modify the regex behavior.
            ///
            /// - Remark: Generated from `#/components/schemas/RegexGroupRule/flags`.
            public var flags: Components.Schemas.RegexGroupRule.flagsPayload?
            /// Creates a new `RegexGroupRule`.
            ///
            /// - Parameters:
            ///   - kind: Discriminator field identifying the rule type as 'regex_group'.
            ///   - pattern: The regular expression pattern containing capture groups `(...)`. The entire pattern must match for replacements to occur.
            ///   - groupReplacements: An object where keys are capture group numbers (as strings, e.g., "1", "2") and values are the respective replacement strings for those groups. Groups not listed are kept as matched. The entire match is reconstructed using these replacements.
            ///   - flags: An array of flags to modify the regex behavior.
            public init(
                kind: Components.Schemas.RegexGroupRule.kindPayload,
                pattern: Swift.String,
                groupReplacements: Components.Schemas.RegexGroupRule.groupReplacementsPayload,
                flags: Components.Schemas.RegexGroupRule.flagsPayload? = nil
            ) {
                self.kind = kind
                self.pattern = pattern
                self.groupReplacements = groupReplacements
                self.flags = flags
            }
            public enum CodingKeys: String, CodingKey {
                case kind
                case pattern
                case groupReplacements
                case flags
            }
        }
        /// Defines a single rule for finding and replacing text in a transcription. Use one of the specific rule types (`ExactRule`, `RegexRule`, `RegexGroupRule`). The `kind` property acts as a discriminator.
        ///
        /// - Remark: Generated from `#/components/schemas/ReplacementRule`.
        @frozen public enum ReplacementRule: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/ReplacementRule/ExactRule`.
            case exact(Components.Schemas.ExactRule)
            /// - Remark: Generated from `#/components/schemas/ReplacementRule/RegexRule`.
            case regex(Components.Schemas.RegexRule)
            /// - Remark: Generated from `#/components/schemas/ReplacementRule/RegexGroupRule`.
            case regex_group(Components.Schemas.RegexGroupRule)
            public enum CodingKeys: String, CodingKey {
                case kind
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                let discriminator = try container.decode(
                    Swift.String.self,
                    forKey: .kind
                )
                switch discriminator {
                case "exact":
                    self = .exact(try .init(from: decoder))
                case "regex":
                    self = .regex(try .init(from: decoder))
                case "regex_group":
                    self = .regex_group(try .init(from: decoder))
                default:
                    throw Swift.DecodingError.unknownOneOfDiscriminator(
                        discriminatorKey: CodingKeys.kind,
                        discriminatorValue: discriminator,
                        codingPath: decoder.codingPath
                    )
                }
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .exact(value):
                    try value.encode(to: encoder)
                case let .regex(value):
                    try value.encode(to: encoder)
                case let .regex_group(value):
                    try value.encode(to: encoder)
                }
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {}
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {
        public struct DualFormatTranscriptionResponse: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/DualFormatTranscriptionResponse/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/DualFormatTranscriptionResponse/content/application\/json`.
                case json(Components.Schemas.TranscriptionResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.TranscriptionResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/DualFormatTranscriptionResponse/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.DualFormatTranscriptionResponse.Body
            /// Creates a new `DualFormatTranscriptionResponse`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.DualFormatTranscriptionResponse.Body) {
                self.body = body
            }
        }
        public struct BadRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/BadRequest/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/BadRequest/content/application\/json`.
                case json(Components.Schemas.ErrorResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ErrorResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.BadRequest.Body
            /// Creates a new `BadRequest`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.BadRequest.Body) {
                self.body = body
            }
        }
        public struct Unauthorized: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/Unauthorized/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/Unauthorized/content/application\/json`.
                case json(Components.Schemas.ErrorResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ErrorResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.Unauthorized.Body
            /// Creates a new `Unauthorized`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.Unauthorized.Body) {
                self.body = body
            }
        }
        public struct PaymentRequired: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/PaymentRequired/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/PaymentRequired/content/application\/json`.
                case json(Components.Schemas.ErrorResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ErrorResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.PaymentRequired.Body
            /// Creates a new `PaymentRequired`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.PaymentRequired.Body) {
                self.body = body
            }
        }
        public struct NotFound: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/NotFound/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/NotFound/content/application\/json`.
                case json(Components.Schemas.ErrorResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ErrorResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.NotFound.Body
            /// Creates a new `NotFound`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.NotFound.Body) {
                self.body = body
            }
        }
        public struct TooManyRequests: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/TooManyRequests/headers`.
            public struct Headers: Sendable, Hashable {
                /// The recommended number of seconds to wait before making another request.
                ///
                /// - Remark: Generated from `#/components/responses/TooManyRequests/headers/Retry-After`.
                public var Retry_hyphen_After: Swift.Int?
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - Retry_hyphen_After: The recommended number of seconds to wait before making another request.
                public init(Retry_hyphen_After: Swift.Int? = nil) {
                    self.Retry_hyphen_After = Retry_hyphen_After
                }
            }
            /// Received HTTP response headers
            public var headers: Components.Responses.TooManyRequests.Headers
            /// - Remark: Generated from `#/components/responses/TooManyRequests/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/TooManyRequests/content/application\/json`.
                case json(Components.Schemas.ErrorResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ErrorResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.TooManyRequests.Body
            /// Creates a new `TooManyRequests`.
            ///
            /// - Parameters:
            ///   - headers: Received HTTP response headers
            ///   - body: Received HTTP response body
            public init(
                headers: Components.Responses.TooManyRequests.Headers = .init(),
                body: Components.Responses.TooManyRequests.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        public struct InternalServerError: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/InternalServerError/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/InternalServerError/content/application\/json`.
                case json(Components.Schemas.ErrorResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ErrorResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/InternalServerError/content/text\/plain`.
                case plainText(OpenAPIRuntime.HTTPBody)
                /// The associated value of the enum case if `self` is `.plainText`.
                ///
                /// - Throws: An error if `self` is not `.plainText`.
                /// - SeeAlso: `.plainText`.
                public var plainText: OpenAPIRuntime.HTTPBody {
                    get throws {
                        switch self {
                        case let .plainText(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "text/plain",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.InternalServerError.Body
            /// Creates a new `InternalServerError`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.InternalServerError.Body) {
                self.body = body
            }
        }
        public struct ServiceUnavailable: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/ServiceUnavailable/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/ServiceUnavailable/content/application\/json`.
                case json(Components.Schemas.ErrorResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ErrorResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.ServiceUnavailable.Body
            /// Creates a new `ServiceUnavailable`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.ServiceUnavailable.Body) {
                self.body = body
            }
        }
        public struct GatewayTimeout: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/GatewayTimeout/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/GatewayTimeout/content/application\/json`.
                case json(Components.Schemas.ErrorResponse)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ErrorResponse {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.GatewayTimeout.Body
            /// Creates a new `GatewayTimeout`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.GatewayTimeout.Body) {
                self.body = body
            }
        }
    }
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Upload an audio file directly and receive a transcription.
    ///
    /// This endpoint allows you to send raw audio data in the request body for transcription.
    /// You can specify the desired model, language, output format, and various provider-specific features using query parameters.
    /// Suitable for transcribing local audio files.
    ///
    ///
    /// - Remark: HTTP `POST /transcribe`.
    /// - Remark: Generated from `#/paths//transcribe/post(transcribe)`.
    public enum transcribe {
        public static let id: Swift.String = "transcribe"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/transcribe/POST/query`.
            public struct Query: Sendable, Hashable {
                /// The identifier of the speech-to-text model to use for the transcription, in the format `provider.model`. See the `/speech-to-text-models` endpoint for available models.
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/model`.
                public var model: Components.Schemas.TranscriptionModelIdentifier
                /// The language of the audio file in ISO 639-1 format (e.g., `en`, `es`, `fr`). Specify `auto` for automatic language detection (if supported by the model). Defaults to `en` if not provided. Providing the correct language improves accuracy and latency.
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/language`.
                public var language: Components.Schemas.TranscriptLanguageCode?
                /// The desired format for the transcription output. Can be plain text, JSON objects (simple or detailed), or subtitle formats (SRT, VTT). Defaults to `text`.
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/output_format`.
                public var output_format: Components.Schemas.TranscriptOutputFormat?
                /// The unique identifier (UUID) of a pre-defined replacement ruleset to apply to the final transcription text. Create rulesets using the `/replacement-rulesets` endpoint.
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/ruleset_id`.
                public var ruleset_id: Swift.String?
                /// Enable automatic punctuation (commas, periods, question marks) in the transcription. Support varies by model/provider (e.g., Deepgram, AssemblyAI). Defaults to `true`.
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/punctuation`.
                public var punctuation: Swift.Bool?
                /// Enable speaker diarization to identify and label different speakers in the audio. Support and quality vary by model/provider. Defaults to `false`. When enabled, the `speaker` field may be populated in the response segments.
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/diarization`.
                public var diarization: Swift.Bool?
                /// An optional text prompt to provide context, guide the model's style (e.g., spelling of specific names), or improve accuracy for subsequent audio segments. Support varies by model (e.g., OpenAI models).
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/initial_prompt`.
                public var initial_prompt: Swift.String?
                /// Controls the randomness of the output for certain models (e.g., OpenAI). A value between 0 and 1. Lower values (e.g., 0.2) make the output more deterministic, while higher values (e.g., 0.8) make it more random. Defaults vary by model.
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/temperature`.
                public var temperature: Swift.Double?
                /// Provides a hint to the diarization process about the number of expected speakers. May improve accuracy for some providers (e.g., RevAI, Deepgram).
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/speakers_expected`.
                public var speakers_expected: Swift.Int?
                /// Provide a list of specific words or phrases (e.g., proper nouns, jargon) to increase their recognition likelihood. Support varies by provider (e.g., Deepgram, AssemblyAI).
                ///
                /// - Remark: Generated from `#/paths/transcribe/POST/query/custom_vocabulary`.
                public var custom_vocabulary: [Swift.String]?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - model: The identifier of the speech-to-text model to use for the transcription, in the format `provider.model`. See the `/speech-to-text-models` endpoint for available models.
                ///   - language: The language of the audio file in ISO 639-1 format (e.g., `en`, `es`, `fr`). Specify `auto` for automatic language detection (if supported by the model). Defaults to `en` if not provided. Providing the correct language improves accuracy and latency.
                ///   - output_format: The desired format for the transcription output. Can be plain text, JSON objects (simple or detailed), or subtitle formats (SRT, VTT). Defaults to `text`.
                ///   - ruleset_id: The unique identifier (UUID) of a pre-defined replacement ruleset to apply to the final transcription text. Create rulesets using the `/replacement-rulesets` endpoint.
                ///   - punctuation: Enable automatic punctuation (commas, periods, question marks) in the transcription. Support varies by model/provider (e.g., Deepgram, AssemblyAI). Defaults to `true`.
                ///   - diarization: Enable speaker diarization to identify and label different speakers in the audio. Support and quality vary by model/provider. Defaults to `false`. When enabled, the `speaker` field may be populated in the response segments.
                ///   - initial_prompt: An optional text prompt to provide context, guide the model's style (e.g., spelling of specific names), or improve accuracy for subsequent audio segments. Support varies by model (e.g., OpenAI models).
                ///   - temperature: Controls the randomness of the output for certain models (e.g., OpenAI). A value between 0 and 1. Lower values (e.g., 0.2) make the output more deterministic, while higher values (e.g., 0.8) make it more random. Defaults vary by model.
                ///   - speakers_expected: Provides a hint to the diarization process about the number of expected speakers. May improve accuracy for some providers (e.g., RevAI, Deepgram).
                ///   - custom_vocabulary: Provide a list of specific words or phrases (e.g., proper nouns, jargon) to increase their recognition likelihood. Support varies by provider (e.g., Deepgram, AssemblyAI).
                public init(
                    model: Components.Schemas.TranscriptionModelIdentifier,
                    language: Components.Schemas.TranscriptLanguageCode? = nil,
                    output_format: Components.Schemas.TranscriptOutputFormat? = nil,
                    ruleset_id: Swift.String? = nil,
                    punctuation: Swift.Bool? = nil,
                    diarization: Swift.Bool? = nil,
                    initial_prompt: Swift.String? = nil,
                    temperature: Swift.Double? = nil,
                    speakers_expected: Swift.Int? = nil,
                    custom_vocabulary: [Swift.String]? = nil
                ) {
                    self.model = model
                    self.language = language
                    self.output_format = output_format
                    self.ruleset_id = ruleset_id
                    self.punctuation = punctuation
                    self.diarization = diarization
                    self.initial_prompt = initial_prompt
                    self.temperature = temperature
                    self.speakers_expected = speakers_expected
                    self.custom_vocabulary = custom_vocabulary
                }
            }
            public var query: Operations.transcribe.Input.Query
            /// - Remark: Generated from `#/paths/transcribe/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.transcribe.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.transcribe.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.transcribe.Input.Headers
            /// - Remark: Generated from `#/paths/transcribe/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/transcribe/POST/requestBody/content/audio\/*`.
                case audio__ast_(OpenAPIRuntime.HTTPBody)
            }
            public var body: Operations.transcribe.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                query: Operations.transcribe.Input.Query,
                headers: Operations.transcribe.Input.Headers = .init(),
                body: Operations.transcribe.Input.Body
            ) {
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            /// Successful transcription response. The content type and structure depend on the `output_format` parameter specified in the request.
            /// - `application/json`: Returned for `output_format=json` or `json_text`. See `TranscriptionResponse` schema (`TranscriptionDetailed` or `TranscriptionOnlyText`).
            /// - `text/plain`: Returned for `output_format=text`.
            ///
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Components.Responses.DualFormatTranscriptionResponse)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Components.Responses.DualFormatTranscriptionResponse {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request - The request was malformed or contained invalid parameters (e.g., invalid language code, missing required field, unsupported option). The response body provides details.
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized - Authentication failed. The API key is missing, invalid, or expired.
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Payment Required - There is no credit left on your account.
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/402`.
            ///
            /// HTTP response code: `402 code402`.
            case code402(Components.Responses.PaymentRequired)
            /// The associated value of the enum case if `self` is `.code402`.
            ///
            /// - Throws: An error if `self` is not `.code402`.
            /// - SeeAlso: `.code402`.
            public var code402: Components.Responses.PaymentRequired {
                get throws {
                    switch self {
                    case let .code402(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "code402",
                            response: self
                        )
                    }
                }
            }
            /// Not Found - The requested resource could not be found. This could be an invalid API endpoint path, or a referenced resource ID (like `ruleset_id`) that doesn't exist. For `/transcribe-remote`, it could also mean the `file_url` was inaccessible.
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too Many Requests - The client has exceeded the rate limit for API requests. Check the `Retry-After` header for guidance on when to retry.
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// Internal Server Error - An unexpected error occurred on the server side while processing the request. Retrying the request later might succeed. If the problem persists, contact support.
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service Unavailable - The server is temporarily unable to handle the request, possibly due to maintenance or overload. Try again later.
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server (e.g., the underlying STT provider). This might be a temporary issue with the provider.
            ///
            /// - Remark: Generated from `#/paths//transcribe/post(transcribe)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Transcribe an audio file located at a remote URL.
    ///
    /// This endpoint allows you to transcribe an audio file hosted at a publicly accessible URL.
    /// Provide the URL and transcription options within the JSON request body.
    /// Useful for transcribing files already stored online.
    ///
    ///
    /// - Remark: HTTP `POST /transcribe-remote`.
    /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)`.
    public enum transcribeRemote {
        public static let id: Swift.String = "transcribeRemote"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/transcribe-remote/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.transcribeRemote.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.transcribeRemote.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.transcribeRemote.Input.Headers
            /// - Remark: Generated from `#/paths/transcribe-remote/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/transcribe-remote/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.RemoteTranscriptionConfiguration)
            }
            public var body: Operations.transcribeRemote.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.transcribeRemote.Input.Headers = .init(),
                body: Operations.transcribeRemote.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            /// Successful transcription response. The content type and structure depend on the `output_format` parameter specified in the request.
            /// - `application/json`: Returned for `output_format=json` or `json_text`. See `TranscriptionResponse` schema (`TranscriptionDetailed` or `TranscriptionOnlyText`).
            /// - `text/plain`: Returned for `output_format=text`.
            ///
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Components.Responses.DualFormatTranscriptionResponse)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Components.Responses.DualFormatTranscriptionResponse {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request - The request was malformed or contained invalid parameters (e.g., invalid language code, missing required field, unsupported option). The response body provides details.
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized - Authentication failed. The API key is missing, invalid, or expired.
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Payment Required - There is no credit left on your account.
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/402`.
            ///
            /// HTTP response code: `402 code402`.
            case code402(Components.Responses.PaymentRequired)
            /// The associated value of the enum case if `self` is `.code402`.
            ///
            /// - Throws: An error if `self` is not `.code402`.
            /// - SeeAlso: `.code402`.
            public var code402: Components.Responses.PaymentRequired {
                get throws {
                    switch self {
                    case let .code402(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "code402",
                            response: self
                        )
                    }
                }
            }
            /// Not Found - The requested resource could not be found. This could be an invalid API endpoint path, or a referenced resource ID (like `ruleset_id`) that doesn't exist. For `/transcribe-remote`, it could also mean the `file_url` was inaccessible.
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too Many Requests - The client has exceeded the rate limit for API requests. Check the `Retry-After` header for guidance on when to retry.
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// Internal Server Error - An unexpected error occurred on the server side while processing the request. Retrying the request later might succeed. If the problem persists, contact support.
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service Unavailable - The server is temporarily unable to handle the request, possibly due to maintenance or overload. Try again later.
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server (e.g., the underlying STT provider). This might be a temporary issue with the provider.
            ///
            /// - Remark: Generated from `#/paths//transcribe-remote/post(transcribeRemote)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Transcribes audio into the input language, using OpenAI-compatible request format.
    ///
    /// Mimics the OpenAI `/audio/transcriptions` endpoint. Accepts audio file uploads via `multipart/form-data`.
    /// Allows specifying model, language, prompt, response format, temperature, and timestamp granularity similar to OpenAI.
    /// Note: The `model` parameter should use Speechall's `provider.model` format.
    ///
    ///
    /// - Remark: HTTP `POST /openai-compatible/audio/transcriptions`.
    /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)`.
    public enum openaiCompatibleCreateTranscription {
        public static let id: Swift.String = "openaiCompatibleCreateTranscription"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.openaiCompatibleCreateTranscription.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.openaiCompatibleCreateTranscription.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.openaiCompatibleCreateTranscription.Input.Headers
            /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/multipartForm`.
                @frozen public enum multipartFormPayload: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/multipartForm/file`.
                    public struct filePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `filePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case file(OpenAPIRuntime.MultipartPart<Operations.openaiCompatibleCreateTranscription.Input.Body.multipartFormPayload.filePayload>)
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/multipartForm/model`.
                    public struct modelPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `modelPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case model(OpenAPIRuntime.MultipartPart<Operations.openaiCompatibleCreateTranscription.Input.Body.multipartFormPayload.modelPayload>)
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/multipartForm/language`.
                    public struct languagePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `languagePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case language(OpenAPIRuntime.MultipartPart<Operations.openaiCompatibleCreateTranscription.Input.Body.multipartFormPayload.languagePayload>)
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/multipartForm/prompt`.
                    public struct promptPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `promptPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case prompt(OpenAPIRuntime.MultipartPart<Operations.openaiCompatibleCreateTranscription.Input.Body.multipartFormPayload.promptPayload>)
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/multipartForm/response_format`.
                    public struct response_formatPayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `response_formatPayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case response_format(OpenAPIRuntime.MultipartPart<Operations.openaiCompatibleCreateTranscription.Input.Body.multipartFormPayload.response_formatPayload>)
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/multipartForm/temperature`.
                    public struct temperaturePayload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `temperaturePayload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case temperature(OpenAPIRuntime.MultipartPart<Operations.openaiCompatibleCreateTranscription.Input.Body.multipartFormPayload.temperaturePayload>)
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/multipartForm/timestamp_granularities[]`.
                    public struct timestamp_granularities_lbrack__rbrack_Payload: Sendable, Hashable {
                        public var body: OpenAPIRuntime.HTTPBody
                        /// Creates a new `timestamp_granularities_lbrack__rbrack_Payload`.
                        ///
                        /// - Parameters:
                        ///   - body:
                        public init(body: OpenAPIRuntime.HTTPBody) {
                            self.body = body
                        }
                    }
                    case timestamp_granularities_lbrack__rbrack_(OpenAPIRuntime.MultipartPart<Operations.openaiCompatibleCreateTranscription.Input.Body.multipartFormPayload.timestamp_granularities_lbrack__rbrack_Payload>)
                }
                /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/requestBody/content/multipart\/form-data`.
                case multipartForm(OpenAPIRuntime.MultipartBody<Operations.openaiCompatibleCreateTranscription.Input.Body.multipartFormPayload>)
            }
            public var body: Operations.openaiCompatibleCreateTranscription.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.openaiCompatibleCreateTranscription.Input.Headers = .init(),
                body: Operations.openaiCompatibleCreateTranscription.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/responses/200/content/json`.
                    @frozen public enum jsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/responses/200/content/json/case1`.
                        case OpenAI_CreateTranscriptionResponseVerboseJson(Components.Schemas.OpenAI_CreateTranscriptionResponseVerboseJson)
                        /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/responses/200/content/json/case2`.
                        case OpenAI_CreateTranscriptionResponseJson(Components.Schemas.OpenAI_CreateTranscriptionResponseJson)
                        public init(from decoder: any Decoder) throws {
                            var errors: [any Error] = []
                            do {
                                self = .OpenAI_CreateTranscriptionResponseVerboseJson(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            do {
                                self = .OpenAI_CreateTranscriptionResponseJson(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            throw Swift.DecodingError.failedToDecodeOneOfSchema(
                                type: Self.self,
                                codingPath: decoder.codingPath,
                                errors: errors
                            )
                        }
                        public func encode(to encoder: any Encoder) throws {
                            switch self {
                            case let .OpenAI_CreateTranscriptionResponseVerboseJson(value):
                                try value.encode(to: encoder)
                            case let .OpenAI_CreateTranscriptionResponseJson(value):
                                try value.encode(to: encoder)
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/responses/200/content/application\/json`.
                    case json(Operations.openaiCompatibleCreateTranscription.Output.Ok.Body.jsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.openaiCompatibleCreateTranscription.Output.Ok.Body.jsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/transcriptions/POST/responses/200/content/text\/plain`.
                    case plainText(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.plainText`.
                    ///
                    /// - Throws: An error if `self` is not `.plainText`.
                    /// - SeeAlso: `.plainText`.
                    public var plainText: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .plainText(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "text/plain",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.openaiCompatibleCreateTranscription.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.openaiCompatibleCreateTranscription.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Transcription successful. The response body format depends on the `response_format` parameter specified in the request:
            /// - `json`: Returns `OpenAI_CreateTranscriptionResponseJson`.
            /// - `verbose_json`: Returns `OpenAI_CreateTranscriptionResponseVerboseJson` with detailed segments and optional word timestamps.
            /// - `text`, `srt`, `vtt`: Returns the transcription as plain text in the specified format.
            ///
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.openaiCompatibleCreateTranscription.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.openaiCompatibleCreateTranscription.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request - The request was malformed or contained invalid parameters (e.g., invalid language code, missing required field, unsupported option). The response body provides details.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized - Authentication failed. The API key is missing, invalid, or expired.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Payment Required - There is no credit left on your account.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/402`.
            ///
            /// HTTP response code: `402 code402`.
            case code402(Components.Responses.PaymentRequired)
            /// The associated value of the enum case if `self` is `.code402`.
            ///
            /// - Throws: An error if `self` is not `.code402`.
            /// - SeeAlso: `.code402`.
            public var code402: Components.Responses.PaymentRequired {
                get throws {
                    switch self {
                    case let .code402(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "code402",
                            response: self
                        )
                    }
                }
            }
            /// Not Found - The requested resource could not be found. This could be an invalid API endpoint path, or a referenced resource ID (like `ruleset_id`) that doesn't exist. For `/transcribe-remote`, it could also mean the `file_url` was inaccessible.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too Many Requests - The client has exceeded the rate limit for API requests. Check the `Retry-After` header for guidance on when to retry.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// Internal Server Error - An unexpected error occurred on the server side while processing the request. Retrying the request later might succeed. If the problem persists, contact support.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service Unavailable - The server is temporarily unable to handle the request, possibly due to maintenance or overload. Try again later.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server (e.g., the underlying STT provider). This might be a temporary issue with the provider.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/transcriptions/post(openaiCompatibleCreateTranscription)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Translates audio into English, using OpenAI-compatible request format.
    ///
    /// Mimics the OpenAI `/audio/translations` endpoint. Accepts audio file uploads via `multipart/form-data` and translates the speech into English text.
    /// Allows specifying model, prompt, response format, and temperature similar to OpenAI.
    /// Note: The `model` parameter should use Speechall's `provider.model` format (ensure the selected model supports translation).
    ///
    ///
    /// - Remark: HTTP `POST /openai-compatible/audio/translations`.
    /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)`.
    public enum openaiCompatibleCreateTranslation {
        public static let id: Swift.String = "openaiCompatibleCreateTranslation"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.openaiCompatibleCreateTranslation.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.openaiCompatibleCreateTranslation.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.openaiCompatibleCreateTranslation.Input.Headers
            /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/requestBody/content/multipart\/form-data`.
                case multipartForm(OpenAPIRuntime.MultipartBody<Components.Schemas.OpenAI_CreateTranslationRequest>)
            }
            public var body: Operations.openaiCompatibleCreateTranslation.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.openaiCompatibleCreateTranslation.Input.Headers = .init(),
                body: Operations.openaiCompatibleCreateTranslation.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/responses/200/content/json`.
                    @frozen public enum jsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/responses/200/content/json/case1`.
                        case OpenAI_CreateTranslationResponseVerboseJson(Components.Schemas.OpenAI_CreateTranslationResponseVerboseJson)
                        /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/responses/200/content/json/case2`.
                        case OpenAI_CreateTranslationResponseJson(Components.Schemas.OpenAI_CreateTranslationResponseJson)
                        public init(from decoder: any Decoder) throws {
                            var errors: [any Error] = []
                            do {
                                self = .OpenAI_CreateTranslationResponseVerboseJson(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            do {
                                self = .OpenAI_CreateTranslationResponseJson(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            throw Swift.DecodingError.failedToDecodeOneOfSchema(
                                type: Self.self,
                                codingPath: decoder.codingPath,
                                errors: errors
                            )
                        }
                        public func encode(to encoder: any Encoder) throws {
                            switch self {
                            case let .OpenAI_CreateTranslationResponseVerboseJson(value):
                                try value.encode(to: encoder)
                            case let .OpenAI_CreateTranslationResponseJson(value):
                                try value.encode(to: encoder)
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/responses/200/content/application\/json`.
                    case json(Operations.openaiCompatibleCreateTranslation.Output.Ok.Body.jsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.openaiCompatibleCreateTranslation.Output.Ok.Body.jsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/openai-compatible/audio/translations/POST/responses/200/content/text\/plain`.
                    case plainText(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.plainText`.
                    ///
                    /// - Throws: An error if `self` is not `.plainText`.
                    /// - SeeAlso: `.plainText`.
                    public var plainText: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .plainText(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "text/plain",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.openaiCompatibleCreateTranslation.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.openaiCompatibleCreateTranslation.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Translation successful. The output is always English text. The response body format depends on the `response_format` parameter:
            /// - `json`: Returns `OpenAI_CreateTranslationResponseJson`.
            /// - `verbose_json`: Returns `OpenAI_CreateTranslationResponseVerboseJson` with detailed segments.
            /// - `text`, `srt`, `vtt`: Returns the translated English text as plain text in the specified format.
            ///
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.openaiCompatibleCreateTranslation.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.openaiCompatibleCreateTranslation.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request - The request was malformed or contained invalid parameters (e.g., invalid language code, missing required field, unsupported option). The response body provides details.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized - Authentication failed. The API key is missing, invalid, or expired.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Payment Required - There is no credit left on your account.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/402`.
            ///
            /// HTTP response code: `402 code402`.
            case code402(Components.Responses.PaymentRequired)
            /// The associated value of the enum case if `self` is `.code402`.
            ///
            /// - Throws: An error if `self` is not `.code402`.
            /// - SeeAlso: `.code402`.
            public var code402: Components.Responses.PaymentRequired {
                get throws {
                    switch self {
                    case let .code402(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "code402",
                            response: self
                        )
                    }
                }
            }
            /// Not Found - The requested resource could not be found. This could be an invalid API endpoint path, or a referenced resource ID (like `ruleset_id`) that doesn't exist. For `/transcribe-remote`, it could also mean the `file_url` was inaccessible.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too Many Requests - The client has exceeded the rate limit for API requests. Check the `Retry-After` header for guidance on when to retry.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// Internal Server Error - An unexpected error occurred on the server side while processing the request. Retrying the request later might succeed. If the problem persists, contact support.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service Unavailable - The server is temporarily unable to handle the request, possibly due to maintenance or overload. Try again later.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server (e.g., the underlying STT provider). This might be a temporary issue with the provider.
            ///
            /// - Remark: Generated from `#/paths//openai-compatible/audio/translations/post(openaiCompatibleCreateTranslation)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Create a reusable set of text replacement rules.
    ///
    /// Defines a named set of replacement rules (exact match, regex) that can be applied during transcription requests using its `ruleset_id`.
    /// Rules within a set are applied sequentially to the transcription text.
    ///
    ///
    /// - Remark: HTTP `POST /replacement-rulesets`.
    /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)`.
    public enum createReplacementRuleset {
        public static let id: Swift.String = "createReplacementRuleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/replacement-rulesets/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createReplacementRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.createReplacementRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.createReplacementRuleset.Input.Headers
            /// - Remark: Generated from `#/paths/replacement-rulesets/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/replacement-rulesets/POST/requestBody/json`.
                public struct jsonPayload: Codable, Hashable, Sendable {
                    /// A user-defined name for this ruleset for easier identification.
                    ///
                    /// - Remark: Generated from `#/paths/replacement-rulesets/POST/requestBody/json/name`.
                    public var name: Swift.String
                    /// An ordered array of replacement rules. Rules are applied in the order they appear in this list. See the `ReplacementRule` schema for different rule types (exact, regex, regex_group).
                    ///
                    /// - Remark: Generated from `#/paths/replacement-rulesets/POST/requestBody/json/rules`.
                    public var rules: [Components.Schemas.ReplacementRule]
                    /// Creates a new `jsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: A user-defined name for this ruleset for easier identification.
                    ///   - rules: An ordered array of replacement rules. Rules are applied in the order they appear in this list. See the `ReplacementRule` schema for different rule types (exact, regex, regex_group).
                    public init(
                        name: Swift.String,
                        rules: [Components.Schemas.ReplacementRule]
                    ) {
                        self.name = name
                        self.rules = rules
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case rules
                    }
                }
                /// - Remark: Generated from `#/paths/replacement-rulesets/POST/requestBody/content/application\/json`.
                case json(Operations.createReplacementRuleset.Input.Body.jsonPayload)
            }
            public var body: Operations.createReplacementRuleset.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.createReplacementRuleset.Input.Headers = .init(),
                body: Operations.createReplacementRuleset.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/replacement-rulesets/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/replacement-rulesets/POST/responses/201/content/json`.
                    public struct jsonPayload: Codable, Hashable, Sendable {
                        /// The unique identifier (UUID) generated for this ruleset. Use this ID in the `ruleset_id` parameter of transcription requests.
                        ///
                        /// - Remark: Generated from `#/paths/replacement-rulesets/POST/responses/201/content/json/id`.
                        public var id: Swift.String
                        /// Creates a new `jsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - id: The unique identifier (UUID) generated for this ruleset. Use this ID in the `ruleset_id` parameter of transcription requests.
                        public init(id: Swift.String) {
                            self.id = id
                        }
                        public enum CodingKeys: String, CodingKey {
                            case id
                        }
                    }
                    /// - Remark: Generated from `#/paths/replacement-rulesets/POST/responses/201/content/application\/json`.
                    case json(Operations.createReplacementRuleset.Output.Created.Body.jsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.createReplacementRuleset.Output.Created.Body.jsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.createReplacementRuleset.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.createReplacementRuleset.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Ruleset created successfully. The response body contains the unique ID assigned to the new ruleset.
            ///
            /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.createReplacementRuleset.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.createReplacementRuleset.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request - The request was malformed or contained invalid parameters (e.g., invalid language code, missing required field, unsupported option). The response body provides details.
            ///
            /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized - Authentication failed. The API key is missing, invalid, or expired.
            ///
            /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Payment Required - There is no credit left on your account.
            ///
            /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)/responses/402`.
            ///
            /// HTTP response code: `402 code402`.
            case code402(Components.Responses.PaymentRequired)
            /// The associated value of the enum case if `self` is `.code402`.
            ///
            /// - Throws: An error if `self` is not `.code402`.
            /// - SeeAlso: `.code402`.
            public var code402: Components.Responses.PaymentRequired {
                get throws {
                    switch self {
                    case let .code402(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "code402",
                            response: self
                        )
                    }
                }
            }
            /// Too Many Requests - The client has exceeded the rate limit for API requests. Check the `Retry-After` header for guidance on when to retry.
            ///
            /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// Internal Server Error - An unexpected error occurred on the server side while processing the request. Retrying the request later might succeed. If the problem persists, contact support.
            ///
            /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service Unavailable - The server is temporarily unable to handle the request, possibly due to maintenance or overload. Try again later.
            ///
            /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server (e.g., the underlying STT provider). This might be a temporary issue with the provider.
            ///
            /// - Remark: Generated from `#/paths//replacement-rulesets/post(createReplacementRuleset)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
    /// Retrieve a list of all available speech-to-text models.
    ///
    /// Returns a detailed list of all STT models accessible through the Speechall API.
    /// Each model entry includes its identifier (`provider.model`), display name, description,
    /// supported features (languages, formats, punctuation, diarization), and performance characteristics.
    /// Use this endpoint to discover available models and their capabilities before making transcription requests.
    ///
    ///
    /// - Remark: HTTP `GET /speech-to-text-models`.
    /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)`.
    public enum listSpeechToTextModels {
        public static let id: Swift.String = "listSpeechToTextModels"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/speech-to-text-models/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.listSpeechToTextModels.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.listSpeechToTextModels.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.listSpeechToTextModels.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            public init(headers: Operations.listSpeechToTextModels.Input.Headers = .init()) {
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/speech-to-text-models/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/speech-to-text-models/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.SpeechToTextModel])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.SpeechToTextModel] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.listSpeechToTextModels.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.listSpeechToTextModels.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// A list of available speech-to-text models and their properties.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.listSpeechToTextModels.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.listSpeechToTextModels.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request - The request was malformed or contained invalid parameters (e.g., invalid language code, missing required field, unsupported option). The response body provides details.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Unauthorized - Authentication failed. The API key is missing, invalid, or expired.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.Unauthorized)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Payment Required - There is no credit left on your account.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/402`.
            ///
            /// HTTP response code: `402 code402`.
            case code402(Components.Responses.PaymentRequired)
            /// The associated value of the enum case if `self` is `.code402`.
            ///
            /// - Throws: An error if `self` is not `.code402`.
            /// - SeeAlso: `.code402`.
            public var code402: Components.Responses.PaymentRequired {
                get throws {
                    switch self {
                    case let .code402(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "code402",
                            response: self
                        )
                    }
                }
            }
            /// Not Found - The requested resource could not be found. This could be an invalid API endpoint path, or a referenced resource ID (like `ruleset_id`) that doesn't exist. For `/transcribe-remote`, it could also mean the `file_url` was inaccessible.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Too Many Requests - The client has exceeded the rate limit for API requests. Check the `Retry-After` header for guidance on when to retry.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/429`.
            ///
            /// HTTP response code: `429 tooManyRequests`.
            case tooManyRequests(Components.Responses.TooManyRequests)
            /// The associated value of the enum case if `self` is `.tooManyRequests`.
            ///
            /// - Throws: An error if `self` is not `.tooManyRequests`.
            /// - SeeAlso: `.tooManyRequests`.
            public var tooManyRequests: Components.Responses.TooManyRequests {
                get throws {
                    switch self {
                    case let .tooManyRequests(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "tooManyRequests",
                            response: self
                        )
                    }
                }
            }
            /// Internal Server Error - An unexpected error occurred on the server side while processing the request. Retrying the request later might succeed. If the problem persists, contact support.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalServerError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalServerError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service Unavailable - The server is temporarily unable to handle the request, possibly due to maintenance or overload. Try again later.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Gateway Timeout - The server, while acting as a gateway or proxy, did not receive a timely response from an upstream server (e.g., the underlying STT provider). This might be a temporary issue with the provider.
            ///
            /// - Remark: Generated from `#/paths//speech-to-text-models/get(listSpeechToTextModels)/responses/504`.
            ///
            /// HTTP response code: `504 gatewayTimeout`.
            case gatewayTimeout(Components.Responses.GatewayTimeout)
            /// The associated value of the enum case if `self` is `.gatewayTimeout`.
            ///
            /// - Throws: An error if `self` is not `.gatewayTimeout`.
            /// - SeeAlso: `.gatewayTimeout`.
            public var gatewayTimeout: Components.Responses.GatewayTimeout {
                get throws {
                    switch self {
                    case let .gatewayTimeout(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "gatewayTimeout",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case plainText
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "text/plain":
                    self = .plainText
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .plainText:
                    return "text/plain"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .plainText
                ]
            }
        }
    }
}
